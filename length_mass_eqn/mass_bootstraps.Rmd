---
title: "Mass Bootstraps"
author: "Selina Agbayani"
date: "November 8, 2018, updated and cleaned July 3, 2025"
output: 
  github_document: default
  html_document: default
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(error = TRUE)


## Setup

# Initialize all libraries, set paths for output figures, then import the gw_observations.csv
# install.packages("tidyr")
# install.packages("tidyverse")
# install.packages("dplyr")
# install.packages("ggplot2")
# install.packages("knitr")
# install.packages("nls2")
# install.packages("nlstools")
# install.packages("nlme")
# install.packages("minpack.lm")
# install.packages("scales")
# install.packages("ggpmisc")
# install.packages("broom")
# install.packages("extrafont")
# install.packages("simpleboot")
# install.packages("car")


library(tidyr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(knitr)
library(nls2)
library(nlstools)
library(nlme)
library(minpack.lm)
library(scales)
library(ggpmisc)
library(reshape2)
library(broom)
library(extrafont)
library(simpleboot)
library(car)

######### PULL IN EXTRA FONTS FOR GRAPHS  ######
font_import() # Prepare for this to take several minutes
loadfonts(device = "win")


```



```{r declare functions and global variables, include=FALSE}

# **Declare custom functions and global variables**
########## Specify Decimal function ############################
# 
# For use in labelling the plots with equations, and rounding up the coefficients
# to a specific no. of decimal places
specify_decimal <- function(x, k) format(round(x, k), nsmall=k)


############ Multiple plot function######################
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
# Code extracted from Cookbook for R. This site is powered by knitr and Jekyll. 
# If you find any errors, please email winston@stdout.org

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


########### functions used for carry out the fit ########

## this function is avaible in: 
# http://www.leg.ufpr.br/~walmes/cursoR/ciaeear/as.lm.R   or in 
# https://gist.github.com/TonyLadson/2d63ca70eef92583001dece607127759 (from the line 269)

##### as.lm function: ######

        as.lm <- function(object, ...) UseMethod("as.lm")

        as.lm.nls <- function(object, ...) {
            if (!inherits(object, "nls")) {
                w <- paste("expected object of class nls but got object of class:", 
                    paste(class(object), collapse = " "))
                warning(w)
            }

            gradient <- object$m$gradient()
            if (is.null(colnames(gradient))) {
                colnames(gradient) <- names(object$m$getPars())
            }

            response.name <- if (length(formula(object)) == 2) "0" else 
                as.character(formula(object)[[2]])

            lhs <- object$m$lhs()
            L <- data.frame(lhs, gradient)
            names(L)[1] <- response.name

            fo <- sprintf("%s ~ %s - 1", response.name, 
                paste(colnames(gradient), collapse = "+"))
            fo <- as.formula(fo, env = as.proto.list(L))

            do.call("lm", list(fo, offset = substitute(fitted(object))))

        }

############## End as.lm function 



############### proto function: ############
#### proto function avaible in https://github.com/hadley/proto/blob/master/R/proto.R

proto <- function(. = parent.env(envir), expr = {},
                   envir = new.env(parent = parent.frame()), ...,
                   funEnvir = envir) {
  parent.env(envir) <- .
  envir <- as.proto.environment(envir)  # must do this before eval(...)
  # moved eval after for so that ... always done first
  # eval(substitute(eval(quote({ expr }))), envir)
  dots <- list(...); names <- names(dots)
  for (i in seq_along(dots)) {
    assign(names[i], dots[[i]], envir = envir)
    if (!identical(funEnvir, FALSE) && is.function(dots[[i]]))
      environment(envir[[names[i]]]) <- funEnvir
  }
  eval(substitute(eval(quote({
    expr
  }))), envir)
  if (length(dots))
    as.proto.environment(envir)
  else
    envir
}

#' @export
#' @rdname proto
as.proto <- function(x, ...) {
  UseMethod("as.proto")
}

#' @export
#' @rdname proto
as.proto.environment <- function(x, ...) {
  assign(".that", x, envir = x)
  assign(".super", parent.env(x), envir = x)
  structure(x, class = c("proto", "environment"))
}

#' @export
#' @rdname proto
as.proto.proto <- function(x, ...) {
  x
}
as.proto.list <- function(x, envir, parent, all.names = FALSE, ...,
                          funEnvir = envir, SELECT = function(x) TRUE) {
  if (missing(envir)) {
    if (missing(parent))
      parent <- parent.frame()
    envir <- if (is.proto(parent))
      parent$proto(...)
    else
      proto(parent, ...)
  }
  for (s in names(x))
    if (SELECT(x[[s]])) {
      assign(s, x[[s]], envir = envir)
      if (is.function(x[[s]]) && !identical(funEnvir, FALSE))
        environment(envir[[s]]) <- funEnvir
    }
  if (!missing(parent))
    parent.env(envir) <- parent
  as.proto.environment(envir)  # force refresh of .that and .super
}

#' @export
"$<-.proto" <- function(this,s,value) {
  if (s == ".super")
    parent.env(this) <- value
  if (is.function(value))
    environment(value) <- this
  this[[as.character(substitute(s))]] <- value
  this
}
is.proto <- function(x) inherits(x, "proto")

#' @export
"$.proto" <- function(x, name) {
  inherits <- substr(name, 1, 2) != ".."

  res <- get(name, envir = x, inherits = inherits)
  if (!is.function(res))
    return(res)

  if (deparse(substitute(x)) %in% c(".that", ".super"))
    return(res)

  structure(
    function(...) res(x, ...),
    class = "protoMethod",
    method = res
  )
}

#' @export
print.protoMethod <- function(x, ...) {
  cat("<ProtoMethod>\n")
  print(attr(x, "method"), ...)
}

# modified from Tom Short's original
#' @export
str.proto <- function(object, max.level = 1, nest.lev = 0,
                      indent.str = paste(rep.int(" ", max(0, nest.lev + 1)), collapse = ".."),
                      ...) {
  cat("proto", name.proto(object), "\n")
  Lines <- utils::capture.output(utils::str(
    as.list(object), max.level = max.level,
    nest.lev = nest.lev, ...
  ))[-1]
  for (s in Lines)
    cat(s, "\n")
  if (is.proto(parent.env(object))) {
    cat(indent.str, "parent: ", sep = "")
    utils::str(parent.env(object), nest.lev = nest.lev + 1, ...)
  }
}

#' @export
print.proto <- function(x, ...) {
  if (!exists("proto_print", envir = x, inherits = TRUE))
    return(NextMethod())

  x$proto_print(...)
}

############# End proto function 

############ PredictNLS - for confidence intervals  ##########
# Source: https://rmazing.wordpress.com/2013/08/14/predictnls-part-1-monte-carlo-simulation-confidence-intervals-for-nls-models/

predictNLS <- function(object,newdata,level = 0.95, nsim = 10000,
                       ...){
    require(MASS, quietly = TRUE)
    ## get right-hand side of formula
    RHS <- as.list(object$call$formula)[[3]]
    EXPR <- as.expression(RHS)
   
    ## all variables in model
    VARS <- all.vars(EXPR)
   
    ## coefficients
    COEF <- coef(object)
   
    ## extract predictor variable    
    predNAME <- setdiff(VARS, names(COEF))  
   
    ## take fitted values, if 'newdata' is missing
    if (missing(newdata)) {
        newdata <- eval(object$data)[predNAME]
        colnames(newdata) <- predNAME
        }
       
    ## check that 'newdata' has same name as predVAR
    if (names(newdata)[1] != predNAME) stop("newdata should have name '",
                                            predNAME, "'!")
   
    ## get parameter coefficients
    COEF <- coef(object)
     
    ## get variance-covariance matrix
    VCOV <- vcov(object)
   
    ## augment variance-covariance matrix for 'mvrnorm' 
    ## by adding a column/row for 'error in x'
    NCOL <- ncol(VCOV)
    ADD1 <- c(rep(0, NCOL))
    ADD1 <- matrix(ADD1, ncol = 1)
    colnames(ADD1) <- predNAME
    VCOV <- cbind(VCOV, ADD1)
    ADD2 <- c(rep(0, NCOL + 1))
    ADD2 <- matrix(ADD2, nrow = 1)
    rownames(ADD2) <- predNAME
    VCOV <- rbind(VCOV, ADD2) 
         
    ## iterate over all entries in 'newdata' as in usual 'predict.' functions
    NR <- nrow(newdata)
    respVEC <- numeric(NR)
    seVEC <- numeric(NR)
    varPLACE <- ncol(VCOV)   
   
    ## define counter function
    counter <- function (i) {
        if (i%%10 == 0) 
            cat(i)
        else cat(".")
        if (i%%50 == 0) 
            cat("\n")
        flush.console()
        }
   
    outMAT <- NULL 
   
    for (i in 1:NR) {
        counter(i)
        ## get predictor values and optional errors
    predVAL <- newdata[i, 1]
    if (ncol(newdata) == 2) predERROR <- newdata[i, 2] else predERROR <- 0
    names(predVAL) <- predNAME  
    names(predERROR) <- predNAME  
     
    ## create mean vector for 'mvrnorm'
    MU <- c(COEF, predVAL)
     
    ## create variance-covariance matrix for 'mvrnorm'
    ## by putting error^2 in lower-right position of VCOV
    newVCOV <- VCOV
    newVCOV[varPLACE, varPLACE] <- predERROR^2
     
    ## create MC simulation matrix
    simMAT <- mvrnorm(n = nsim, mu = MU, Sigma = newVCOV, empirical = TRUE)
     
    ## evaluate expression on rows of simMAT
    EVAL <- try(eval(EXPR, envir = as.data.frame(simMAT)), silent = TRUE)
    if (inherits(EVAL, "try-error")) stop("There was an error evaluating the simulations!")
     
    ## collect statistics
    PRED <- data.frame(predVAL)
    colnames(PRED) <- predNAME   
    FITTED <- predict(object, newdata = data.frame(PRED))
    MEAN.sim <- mean(EVAL, na.rm = TRUE)
    SD.sim <- sd(EVAL, na.rm = TRUE)
    MEDIAN.sim <- median(EVAL, na.rm = TRUE)
    MAD.sim <- mad(EVAL, na.rm = TRUE)  #median absolute deviation
    QUANT <- quantile(EVAL, c((1 - level)/2, level + (1 - level)/2))
    RES <- c(FITTED, MEAN.sim, SD.sim, MEDIAN.sim, MAD.sim, QUANT[1], QUANT[2])
    outMAT <- rbind(outMAT, RES)
  }
   
  colnames(outMAT) <- c("fit", "mean", "sd", "median", "mad", names(QUANT[1]), names(QUANT[2]))
  rownames(outMAT) <- NULL
   
  cat("\n")
   
  return(outMAT)  
}

##########end PredictNLS ##########

        
```   


```{r setting paths}       
############ Set path for output figures: ###############
Figurespath <- paste0(getwd(), "/length_mass_eqn/figures", collapse = NULL)
Figurespath
############ Set path for input & output data  ###########
datapath <- paste0(getwd(), "/data", collapse = NULL) 


```

**GREY WHALE LENGTHS AT AGE DATASET**

```{r import data}

#Read in data for predicted lengths per age step (data from Agbayani et al. 2020)  
gw_pred_lengths <- as_tibble(
  read_csv("data/gw_predicted_phases_1_2_mthsversion_Feb2021.csv"),
  col_types = cols(age_yrs = col_double(),
                         fit = col_double(),
                         mean = col_double(),
                         sd = col_double(),
                         median = col_double(),
                         median_abs_dev = col_double(),
                         `2.5%` = col_double(),
                         `97.5%` = col_double(),
                         length_plus_sd = col_double(),
                         length_minus_sd = col_double()
                         )
                   
  )
  
#Read in data for observed age, mass, and length for non-pregnant gray whales 
gw_obs_mass_length_nonpreg <- as_tibble(
  read_csv("data/gw_obs_mass_length_nonpreg.csv",
           col_types = cols(ID = col_integer(),
                             sex = col_character(),
                             age_yrs = col_double(),
                             age_mths = col_double(),
                             age_wks = col_integer(),
                             length_m = col_double(),
                             girth_m = col_double(),
                             mass_kg_x_1000 = col_double(),
                             mass_kg = col_double(),
                             Details = col_character(),
                             source = col_character()
                            )
           )
  )

#Read in age tibble for the first 12 months for Phase 1
age_yr_tibble <- as_tibble(
  read_csv("data/age_yr_tibble.csv"), 
  col_types = cols(ID = col_integer(),
                   month = col_character(),
                   no_days_in_mth = col_double(),
                   age_mth = col_double(),
                   no_days_cumul = col_double(),
                   age_yrs = col_double()
                   )
  )



```


*Fitting the mass/length data to a linear model*

```{r length mass linear model}
#Calculate log base 10 for lengths and masss
gw_obs_mass_length_nonpreg$log10_length_m <- log10(gw_obs_mass_length_nonpreg$length_m)

gw_obs_mass_length_nonpreg$log10_mass_kg <- log10(gw_obs_mass_length_nonpreg$mass_kg)

#assign variable names to columns
log10_length_m <- gw_obs_mass_length_nonpreg$log10_length_m
log10_mass_kg <- gw_obs_mass_length_nonpreg$log10_mass_kg
length_m <- gw_obs_mass_length_nonpreg$length_m
mass_kg <- gw_obs_mass_length_nonpreg$mass_kg

kable(head(gw_obs_mass_length_nonpreg))

#fit linear model
lm_log10 <- lm(log10_mass_kg ~ log10_length_m)

#code above is equivalent to : lm_log10 <- lm(log10(mass_kg) ~ log10(length_m))

summary(lm_log10)

# ## COMMENTED RESULTS FOR CONSISTENCY CHECK ####
# ## Call:
# ## lm(formula = log10_mass_kg ~ log10_length_m)
# ## 
# ## Residuals:
# ##      Min       1Q   Median       3Q      Max 
# ## -0.11144 -0.05568  0.00425  0.04750  0.12669 
# ## 
# ## Coefficients:
# ##                Estimate Std. Error t value Pr(>|t|)    
# ## (Intercept)      1.0354     0.1590   6.511 1.97e-05 ***
# ## log10_length_m   2.9509     0.1693  17.427 2.14e-10 ***
# ## ---
# ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
# ## 
# ## Residual standard error: 0.07205 on 13 degrees of freedom
# ## Multiple R-squared:  0.9589, Adjusted R-squared:  0.9558 
# ## F-statistic: 303.7 on 1 and 13 DF,  p-value: 2.143e-10



```

Create blank mass table

```{r mass table}

kable(head(gw_pred_lengths))

# Create blank data frame for age and predicted length data 
gw_pred_length_mass <- as.data.frame(gw_pred_lengths$age_yrs)
names(gw_pred_length_mass)[1] <-  "age_yrs"
gw_pred_length_mass$length_m <- gw_pred_lengths$fit 
gw_pred_length_mass$length_sd <- gw_pred_lengths$sd

kable(head(gw_pred_length_mass))


# Create blank data frame for age and predicted mass data 
mass_table <- as.data.frame(matrix(ncol = 7, nrow = 0))

cnames <- c("age_yrs", "mass_kg", "mass_sd", 
            "mean_lwr", "mean_upr",       #mean value of 95% CI from predict lm
            "quant025", "quant975"        #2.5% and 97.5% quantile from bootstrap estimates 
            # "calc_025CI", "calc_975CI"  #calculates 95% CI from mass_sd and sample size
            )                             
                                          # calc_025CI and calc_975CI not used 
                                          # because not sure what sample size to use
                                          # i.e. no. bootsrap replicates (10000)?
                                          # or original sample for lm? 14 whales                                            
colnames(mass_table) <- cnames

mass_table <- as.data.frame(mass_table,
                        col_types = list(age_yrs = col_double(),
                                         mass_kg = col_double(),
                                         mass_sd = col_double(),
                                         mean_lwr = col_double(),
                                         mean_upr = col_double(),
                                         quant025 = col_double(),
                                         quant975 = col_double()                    
                                         )
                        )

kable(head(mass_table))



```

Predicting mass per year from linear model for first 12 months

```{r predicting mass phase 1}
# Predict mass 10,000 times per age step, and calculate the mean, 
# sd, lwr, upr and quantiles

age_list <- age_yr_tibble$age_yrs

for (i in age_list){  #step by 0.5 mths
    
    age <- i   #calculate age_yrs (do not round up)


    lengths_at_age <- gw_pred_lengths %>% filter(round(age_yrs,3) == round(age,3))
    
    len <- lengths_at_age$fit
    sd <- lengths_at_age$sd
    
    set.seed(1234)
    pred_lengths <- as.data.frame(rnorm(10000, len, sd))
    names(pred_lengths)[1]<-"length_m"

    pred_lengths$log10_length_m <- log10(pred_lengths$length_m)
    
    predicted_mass <- as.data.frame(predict.lm(object = lm_log10, 
                                       newdata = pred_lengths,
                                       interval = "confidence",
                                       level = 0.95
                                       )
                               )  
    
    pred_lengths$mass_kg <- 10^predicted_mass$fit
    pred_lengths$mass_lwr <- 10^predicted_mass$lwr
    pred_lengths$mass_upr <- 10^predicted_mass$upr
    
    mean_mass <-  mean(pred_lengths$mass_kg)
    sd_mass <- sd(pred_lengths$mass_kg)
    mean_lwr <- mean(pred_lengths$mass_lwr)
    mean_upr <- mean(pred_lengths$mass_upr)
    quant025 <- quantile(pred_lengths$mass_kg, 0.025, na.rm = TRUE)
    quant975 <- quantile(pred_lengths$mass_kg, 0.975, na.rm = TRUE)
    # calc_025CI <- mean_mass - 1.96 * (sd_mass/sqrt(14))  #z-score at 95% = 1.96
    # calc_975CI <- mean_mass + 1.96 * (sd_mass/sqrt(14))
    
    age_yrs = age
    
    # create new row of predicted mass data for each age step
    row <- NULL
    row <- as_tibble(cbind(age_yrs, mean_mass, sd_mass, 
                           mean_lwr, mean_upr, 
                           quant025, quant975
                           #calc_025CI,calc_975CI
                           )
                     )
    # append new row of predicted mass data for each age step
    mass_table <- rbind(mass_table, row)

}


mass_table <- mass_table %>% filter(!is.na(mean_mass))

kable(head(mass_table))
```

Predicting mass per year from linear model for ages >1 yr 

```{r predicting mass phase 2}

# Predict mass 10,000 times per age step (0.5 yrs), and calculate the mean, 
# sd, lwr, upr and quantiles

for (i in seq(from = 1.5, to = 75, by = 0.5)){
    age <-  i 
    
    lengths_at_age <- filter(gw_pred_lengths, age_yrs == age)
    
    len <- lengths_at_age$fit
    sd <- lengths_at_age$sd
    
    set.seed(1234)
    pred_lengths <- as.data.frame(rnorm(10000, len, sd))
    names(pred_lengths)[1]<-"length_m"

    pred_lengths$log10_length_m <- log10(pred_lengths$length_m)
    
    predicted_mass <- as.data.frame(predict.lm(object = lm_log10, 
                                       newdata = pred_lengths, 
                                       interval = "confidence",
                                       level = 0.95
                                       )
                               )  
    
    pred_lengths$mass_kg <- 10^predicted_mass$fit
    pred_lengths$mass_lwr <- 10^predicted_mass$lwr
    pred_lengths$mass_upr <- 10^predicted_mass$upr
    
    mean_mass <-  mean(pred_lengths$mass_kg)
    sd_mass <- sd(pred_lengths$mass_kg)
    mean_lwr <- mean(pred_lengths$mass_lwr)
    mean_upr <- mean(pred_lengths$mass_upr)
    quant025 <- quantile(pred_lengths$mass_kg, 0.025, na.rm = TRUE)
    quant975 <- quantile(pred_lengths$mass_kg, 0.975, na.rm = TRUE)
    #calc_025CI <- mean_mass - 1.96 * (sd_mass/sqrt(14))  #z-score at 95% = 1.96. what n?
    #calc_975CI <- mean_mass + 1.96 * (sd_mass/sqrt(14))
    
    age_yrs = age
    
    # create new row of predicted mass data for each age step
    row <- NULL
    row <- as_tibble(cbind(age_yrs, mean_mass, sd_mass, 
                               mean_lwr, mean_upr, 
                               quant025, quant975
                               #calc_025CI,calc_975CI
                               )
                         )
    # append new row of predicted mass data for each age step
    mass_table <- rbind(mass_table, row)
}


kable(head(mass_table))





```

*Plotting mass data onto graphs*

```{r mass plots, echo=FALSE}

plot_age_mass_black <- mass_table %>% 
    filter(age_yrs <=30) %>% 
    ggplot(mapping = aes(x = age_yrs, y = mean_mass)) +
    xlab("Age (yrs)") +
    ylab(bquote('Mass (kg)')) +
    scale_x_continuous(limits  =c(0,30),
                           breaks = scales::pretty_breaks(n = 10)) +
    scale_y_continuous(limits = c(0,(max(quant975)+2000)), 
                       breaks = scales::pretty_breaks(n = 10),
                       labels = scales::comma) +
    geom_line(aes(y = mean_mass), 
              colour = "white", 
              linetype = "solid", 
              linewidth = 1.0) +
    # geom_line(aes(y = upr), 
    #           colour = "gray", 
    #           linetype = "dashed", 
    #           linewidth = 1.0) + 
    # geom_line(aes(y = lwr), 
    #           colour = "gray", 
    #           linetype = "dashed",
    #           linewidth = 1.0) +
    geom_line(aes(y = mean_mass + sd_mass),
              colour = "white",
              linetype = "dashed",
              linewidth = 0.5) +
    geom_line(aes(y = mean_mass - sd_mass),
              colour = "white",
              linetype = "dashed",
              linewidth = 0.5) +
    # geom_line(aes(y = quant025),
    #           colour = "white",
    #           linetype = "dashed",
    #           linewidth = 0.5) +
    # geom_line(aes(y = quant975),
    #           colour = "white",
    #           linetype = "dashed",
    #           linewidth = 0.5) +

    theme_bw() +
    theme(panel.grid = element_blank()) +       
          # axis.title.x = element_text(size = rel(0.5), colour = "white"),
          # axis.text.x = element_text(size = rel(0.5), colour = "white"),
          # axis.title.y = element_text(size = rel(1.4), colour = "black"),
          # axis.text.y = element_text(size = rel(1.2), colour = "black")
          
    ggtitle(element_blank()) +
    theme(legend.title = element_blank()) +
    theme(legend.position.inside = c(0.8, 0.2)) +
    theme(legend.justification = c(0.98,0.01))+
    theme(legend.background = element_rect(fill = "black"))+
    theme(legend.text = element_text(colour = "white", size = rel(1)))+
    theme(legend.key = element_rect(fill = "transparent"))+ #colour = "transparent"))+
    
    theme(plot.background = element_rect(fill = "black"))+
    
    theme(panel.background = element_rect(fill = "black"))+
    theme(panel.border = element_blank())+
    
    theme(axis.line = element_line(linewidth = 1, colour = "white"))+
    theme(axis.text = element_text(colour = "white", size = rel(1.6)))+
    theme(axis.title.y = element_text(colour = "white", size = rel(1.8), angle = 90))+
    theme(axis.title.x = element_text(colour = "white", size = rel(1.8)))+
    theme(axis.ticks = element_line(colour="white"))
    

plot_age_mass_black



plot_age_mass <- mass_table %>% 
    filter(age_yrs <=30) %>% 
    ggplot(mapping = aes(x = age_yrs, y = mean_mass)) +
    xlab("Age (yrs)") +
    ylab(bquote('Mass (kg)')) +
    scale_x_continuous(limits  =c(0,33),
                           breaks = scales::pretty_breaks(n = 10)) +
    scale_y_continuous(limits = c(0,(max(quant975)+2000)), 
                       breaks = scales::pretty_breaks(n = 10),
                       labels = scales::comma) +
    geom_line(aes(y = mean_mass), 
              colour = "black", 
              linetype = "solid", 
              linewidth = 1.0) +
    # geom_line(aes(y = upr), 
    #           colour = "gray", 
    #           linetype = "dashed", 
    #           linewidth = 1.0) + 
    # geom_line(aes(y = lwr), 
    #           colour = "gray", 
    #           linetype = "dashed",
    #           linewidth = 1.0) +
    # geom_line(aes(y = mean_mass + sd_mass),
    #           colour = "blue",
    #           linetype = "dashed",
    #           linewidth = 0.5) +
    # geom_line(aes(y = mean_mass - sd_mass),
    #           colour = "blue",
    #           linetype = "dashed",
    #           linewidth = 0.5) +
    geom_line(aes(y = quant025),
              colour = "black",
              linetype = "dashed",
              linewidth = 0.5) +
    geom_line(aes(y = quant975),
              colour = "black",
              linetype = "dashed",
              linewidth = 0.5) +

    theme_bw() +
    theme(panel.grid = element_blank(),        
          axis.title.x = element_text(size = rel(1.4), colour = "black"),
          axis.text.x = element_text(size = rel(1.2), colour = "black"),
          axis.title.y = element_text(size = rel(1.4), colour = "black"),
          axis.text.y = element_text(size = rel(1.2), colour = "black")
          ) 
    

plot_age_mass


```

*Plotting sex-specific mass curves*

```{r sex specific mass curves}

# Percent diffs between measured predicted lengths 
# Correction factors for sexual dimorphism (data from Agbayani et al. 2020)

# --------------- PHASE 1 (< 1.5yr) ---------------
# if means are aggregated by year
# |sex     | mean_delta_length| mean_percent_diffs| sd_percent_diffs|
# |:-------|-----------------:|------------------:|----------------:|
# |Female  |         0.2875647|           4.141169|        0.0026405|
# |Male    |         0.3486719|           3.661017|        5.4187345|
# |Unknown |         0.9316482|          14.413196|       18.7861008|


# --------------- PHASE 2 (> 1.5yr) ---------------
# |sex     | mean_delta_length| mean_percent_diffs| sd_percent_diffs|
# |:-------|-----------------:|------------------:|----------------:|
# |Female  |         0.3754025|           2.848439|         3.004057|
# |Male    |        -0.1940471|          -1.592700|         3.330088|
# |Unknown |         0.1376889|           1.445391|         1.574740|

corr_factor_phase1f = (100+4.141169)/100
corr_factor_phase1m = (100+3.3600778)/100
corr_factor_phase2f = (100+2.848439)/100
corr_factor_phase2m = (100-1.592700)/100


mean_mass <- mass_table$mean_mass 

mass_table$female_mass <- mean_mass * corr_factor_phase2f # mean mass x 102.85 %
mass_table$male_mass <- mean_mass * corr_factor_phase2m   # mean mass x 98.4 %

female_mass <- mass_table$female_mass
male_mass <- mass_table$male_mass

kable(head(mass_table))
#kable(mass_table)

#save mass_table csv
mass_table %>% write_csv("data/mass_table.csv", na = "", append = FALSE)

```


Predicted Mass by sex

```{r plot age mass by sex, echo=FALSE}

#Create white plot in  black background  
plot_age_mass_bysex_black <- mass_table %>% 
    filter(age_yrs <=30) %>% 
    ggplot() +
    xlab("Age (yrs)") +
    ylab(bquote('Mass (kg)')) +
    scale_x_continuous(limits  =c(0,32),
                       breaks = scales::pretty_breaks(n = 10)) +
    scale_y_continuous(limits = c(0, max(female_mass)+2000), 
                       breaks = scales::pretty_breaks(n = 10),
                       labels = scales::comma) +
    geom_line(aes(x = age_yrs,
                  y = male_mass), 
              colour = "dodgerblue2", 
              linetype = "solid", 
              linewidth = 1) +
    geom_line(aes(x = age_yrs,
                  y = female_mass), 
              colour = "red1", 
              linetype = "dashed", 
              linewidth = 1) + 
    theme_bw() +
    theme(panel.grid = element_blank(),        
          axis.title.x = element_text(size = rel(1.8), colour = "white"),
          axis.text.x = element_text(size = rel(1.8), colour = "white"),
          axis.title.y = element_text(size = rel(1.8), colour = "white"),
          axis.text.y = element_text(size = rel(1.8), colour = "white")
          ) +
    annotate("text", x = 31, y = 21000, label = "♀",
             size = rel(6), hjust = 0, colour = "red1", 
             family = "Arial", fontface = "bold") +
    annotate("text", x = 31, y = 19900, label = "♂",
             size = rel(6), hjust = 0, colour = "dodgerblue2", 
             family = "Arial", fontface = "bold")+
    theme(panel.grid = element_blank()) +       
          # axis.title.x = element_text(size = rel(0.5), colour = "white"),
          # axis.text.x = element_text(size = rel(0.5), colour = "white"),
          # axis.title.y = element_text(size = rel(1.4), colour = "black"),
          # axis.text.y = element_text(size = rel(1.2), colour = "black")
          
    theme(legend.title = element_blank()) +
    theme(legend.position.inside = c(0.8, 0.2)) +
    theme(legend.justification = c(0.98,0.01))+
    theme(legend.background = element_rect(fill = "black"))+
    theme(legend.text = element_text(colour = "white", size = rel(1)))+
    theme(legend.key = element_rect(fill = "transparent"))+ #colour = "transparent"))+
    ggtitle(element_blank()) +
    theme(plot.background = element_rect(fill = "black"))+
    theme(panel.background = element_rect(fill = "black"))+
    theme(panel.border = element_blank())+
    theme(axis.line = element_line(linewidth = 1, colour = "white"))+
    # theme(axis.text = element_text(colour = "white", size = rel(1.8)))+
    # theme(axis.title.y = element_text(colour = "white", size = rel(1.8), angle = 90))+
    # theme(axis.title.x = element_text(colour = "white", size = rel(2)))+
    theme(axis.ticks = element_line(colour="white"))
    

plot_age_mass_bysex_black



plot_age_mass_bysex <- mass_table %>% 
    filter(age_yrs <=30) %>% 
    ggplot() +
    xlab("Age (yrs)") +
    ylab(bquote('Mass (kg)')) +
    scale_x_continuous(limits  =c(0,33),
                       breaks = scales::pretty_breaks(n = 10)) +
    scale_y_continuous(limits = c(0, max(female_mass)+2000), 
                       breaks = scales::pretty_breaks(n = 10),
                       labels = scales::comma) +
    geom_line(aes(x = age_yrs,
                  y = male_mass), 
              colour = "black", 
              linetype = "solid", 
              linewidth = 1) +
    geom_line(aes(x = age_yrs,
                  y = female_mass), 
              colour = "black", 
              linetype = "dashed", 
              linewidth = 1) + 
    theme_bw() +
    theme(panel.grid = element_blank(),        
          axis.title.x = element_text(size = rel(1.4), colour = "black"),
          axis.text.x = element_text(size = rel(1.2), colour = "black"),
          axis.title.y = element_text(size = rel(0.1), colour = "white"),
          axis.text.y = element_text(size = rel(0.1), colour = "white")
          ) +
    annotate("text", x = 31, y = 20600, label = "♀",
             size = rel(6), hjust = 0, colour = "black", 
             family = "Arial", fontface = "bold") +
    annotate("text", x = 31, y = 19850, label = "♂",
             size = rel(6), hjust = 0, colour = "black", 
             family = "Arial", fontface = "bold")
    

plot_age_mass_bysex

#save multi-panel plot as hi-res jpg
multiplot(plot_age_mass, plot_age_mass_bysex, cols=2)


jpeg(filename = paste0(Figurespath,"/bootstrap_mass_estimates_2panel.jpg"), 
     width = 3000,
     height = 3000,
     pointsize = 35, 
     quality = 100, 
     bg = "white", 
     res = 300, 
     restoreConsole = TRUE)


p <- multiplot(plot_age_mass, 
               plot_age_mass_bysex,
               cols=2)



dev.off()




```

